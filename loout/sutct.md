散列表
  在我的理解中就是数组＋链表的方式也可以数组加树，利用传入数据哈希值来计算要存入的下标，并将这个数据打成链表的格式来连接到下一个位置，如果要查询
  数据的时候获取这个数据的hash值所在的位置依次遍历所有的链表。为了节省数据采用的是单链表的形式

哈夫曼树：
  哈夫曼树用于压缩文件，当一个数据出现的次数过多的时候就采用短码，为了防止前缀发生相同会打成哈夫曼树因为在树中每个叶子节点的路径都不相同也就避    免了前缀发生相同的现象，压缩的大致步骤1.先统计每个字符出现的次数 2.根据每个字符出现的次数打成哈夫曼树 3.取出每一个叶子节点路径和叶子的item    放入map集合中， 4.根据每个字符打成哈夫曼类型的二进制 5.没此截取8个字符打成短码这样就完成压缩

哈夫曼的解码：与压缩相反解压首先会把数据恢复成哈夫曼字符串，之后一步步截取字符串与表进行对比对比成功则放入集合中，最后就完成了解压缩

二叉排序树：特点就是快速查找与快速储存， 特点 左面的比节点小右面比节点大。先说构建一颗二叉排序树：在插入一颗新的叶子的时候首先会与当前的节点进行比较如果新加入的大在判断当前节点的右面是否为空节点如果为空直接挂上，如果不为空则进入右节点在进行判断。同理。递归就是做重复的事情

查找节点：与插入差不多首先会进入当前节点与查找的内容进行判断如果查找的内容相同直接返回，如果查找的内容小于当前节点则递归去当前的左节点继续判断，直到找到为止，如果遍历完毕后也查找不到则直接返回null：大致为进入节点进行判断如果不对在去左或者右进行递归继续判断

删除二叉树节点：删除分为三种情况，被删除的节点没有左右节点，这样直接删除，被删除的节点有左或者右节点在判断出这个节点在父节点的哪个方向直接挂上去，删除的节点右左右节点那么需要在右节点找到最小节点之后与被删除的节点替换

AVL树：
  因为普通的二叉树如果链子过长的话反而不如单链表，这时候需要调整，如果左子树的高度比右子树的高度要高需要向右旋转，如果右子树比左子树高度要高那      么需要右旋转，都需要则双向旋转。
    右旋转：步骤1.创建一个新结点与当前结点相同，新结点的右结点是当前结点的右节点，左节点是当前结点的左子树的右结点，当前结点的替换为当前结点的左子树，而左子树替换为当前的左子树的左子树，右节点为新结点
    左旋转：创建一个与当前结点相同的结点，新结点的左子树等于当前结点的左子树右子树等于当前右子树的左节点，当前结点替换为右子树的值右字数的左结点为新结点，右结点为当前结点的右节点的右结点，
      双向旋转：发现左或者右结点不平衡则触发旋转。
      
      
图
  深度遍历：深度遍历就是一直向下找直到没有回溯到上一层继续找一直直到都结束为止
  广度遍历：广度遍历就是取出第一个值遍历下面的值放到队列中之后依次从队列中取一个值遍历完有就放入集合中直到集合的元素全部被移除完毕
