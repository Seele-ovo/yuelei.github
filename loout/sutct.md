散列表
  在我的理解中就是数组＋链表的方式也可以数组加树，利用传入数据哈希值来计算要存入的下标，并将这个数据打成链表的格式来连接到下一个位置，如果要查询
  数据的时候获取这个数据的hash值所在的位置依次遍历所有的链表。为了节省数据采用的是单链表的形式

哈夫曼树：
  哈夫曼树用于压缩文件，当一个数据出现的次数过多的时候就采用短码，为了防止前缀发生相同会打成哈夫曼树因为在树中每个叶子节点的路径都不相同也就避    免了前缀发生相同的现象，压缩的大致步骤1.先统计每个字符出现的次数 2.根据每个字符出现的次数打成哈夫曼树 3.取出每一个叶子节点路径和叶子的item    放入map集合中， 4.根据每个字符打成哈夫曼类型的二进制 5.没此截取8个字符打成短码这样就完成压缩

哈夫曼的解码：与压缩相反解压首先会把数据恢复成哈夫曼字符串，之后一步步截取字符串与表进行对比对比成功则放入集合中，最后就完成了解压缩

二叉排序树：特点就是快速查找与快速储存， 特点 左面的比节点小右面比节点大。先说构建一颗二叉排序树：在插入一颗新的叶子的时候首先会与当前的节点进行比较如果新加入的大在判断当前节点的右面是否为空节点如果为空直接挂上，如果不为空则进入右节点在进行判断。同理。递归就是做重复的事情

查找节点：与插入差不多首先会进入当前节点与查找的内容进行判断如果查找的内容相同直接返回，如果查找的内容小于当前节点则递归去当前的左节点继续判断，直到找到为止，如果遍历完毕后也查找不到则直接返回null：大致为进入节点进行判断如果不对在去左或者右进行递归继续判断

删除二叉树节点：删除分为三种情况，被删除的节点没有左右节点，这样直接删除，被删除的节点有左或者右节点在判断出这个节点在父节点的哪个方向直接挂上去，删除的节点右左右节点那么需要在右节点找到最小节点之后与被删除的节点替换
